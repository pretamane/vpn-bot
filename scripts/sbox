#!/usr/bin/env bash
# sbox - sing-box TUN proxy manager (tailscale-like CLI)

set -e
set -o pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Config
SERVICE="sing-box"
DNS_SCRIPT="$HOME/.config/sing-box/setup-tun-dns.sh"
CONFIG_FILE="$HOME/.config/sing-box/config.json"

# Helper functions
error() { echo -e "${RED}✗ $*${NC}" >&2; exit 1; }
success() { echo -e "${GREEN}✓ $*${NC}"; }
info() { echo -e "${BLUE}ℹ $*${NC}"; }
warn() { echo -e "${YELLOW}⚠ $*${NC}"; }

check_service() {
    systemctl --user is-active --quiet "$SERVICE" && return 0 || return 1
}

wait_for_proxy_ready() {
    local max_attempts=15
    local attempt=0
    
    info "Waiting for proxy to be ready..."
    
    while [ $attempt -lt $max_attempts ]; do
        attempt=$((attempt + 1))
        
        # Check 1: TUN interface has DNS configured
        if ! resolvectl status tun0 2>/dev/null | grep -q "DNS Servers:"; then
            sleep 1
            continue
        fi
        
        # Check 2: DNS resolution works
        if ! resolvectl query api.ipify.org &>/dev/null; then
            sleep 1
            continue
        fi
        
        # Check 3: HTTP connectivity works
        if curl --fail --silent --connect-timeout 2 --max-time 5 https://api.ipify.org &>/dev/null; then
            success "Proxy ready"
            return 0
        fi
        
        sleep 1
    done
    
    warn "Proxy may still be warming up. Try 'sbox ip' in a few seconds if needed."
    return 1
}

# Subcommands
cmd_up() {
    info "Starting sing-box..."
    systemctl --user start "$SERVICE" || error "Failed to start service"
    sleep 2
    
    if check_service; then
        success "sing-box started"
        
        # Auto DNS fix
        if [[ -x "$DNS_SCRIPT" ]]; then
            info "Configuring TUN DNS..."
            sudo "$DNS_SCRIPT" || warn "DNS setup failed (run: sbox dns)"
        fi
        
        # Wait for proxy to be fully operational
        if wait_for_proxy_ready; then
            echo ""
            cmd_ip
        fi
    else
        error "Service failed to start"
    fi
}

cmd_down() {
    info "Stopping sing-box..."
    systemctl --user stop "$SERVICE" || error "Failed to stop service"
    success "sing-box stopped"
}

cmd_restart() {
    info "Restarting sing-box..."
    systemctl --user restart "$SERVICE" || error "Failed to restart service"
    sleep 2
    
    if check_service; then
        success "sing-box restarted"
        
        # Auto DNS fix
        if [[ -x "$DNS_SCRIPT" ]]; then
            info "Configuring TUN DNS..."
            sudo "$DNS_SCRIPT" || warn "DNS setup failed (run: sbox dns)"
        fi
        
        # Wait for proxy to be fully operational
        if wait_for_proxy_ready; then
            echo ""
            cmd_ip
        fi
    else
        error "Service failed to restart"
    fi
}

cmd_status() {
    echo -e "${BLUE}═══ sing-box Status ═══${NC}"
    
    # Service status
    if check_service; then
        success "Service: running"
    else
        error "Service: stopped"
    fi
    
    # TUN interface
    if ip link show tun0 &>/dev/null; then
        success "TUN interface: up"
        ip addr show tun0 | grep -E "(inet |inet6 )" | sed 's/^/  /'
    else
        warn "TUN interface: down"
    fi
    
    # DNS config
    if resolvectl status tun0 &>/dev/null 2>&1; then
        echo -e "\n${BLUE}DNS Servers:${NC}"
        resolvectl status tun0 | grep "DNS Servers:" | sed 's/^/  /'
    fi
    
    # External IP
    echo -e "\n${BLUE}External IP:${NC}"
    cmd_ip
}

cmd_dns() {
    if [[ "$1" == "reset" ]]; then
        info "Resetting TUN DNS to system default..."
        if ip link show tun0 &>/dev/null; then
            sudo resolvectl revert tun0 || warn "Failed to revert DNS"
            success "TUN DNS reset"
        else
            warn "tun0 interface not found"
        fi
        return
    fi
    
    if [[ ! -x "$DNS_SCRIPT" ]]; then
        error "DNS script not found: $DNS_SCRIPT"
    fi
    
    info "Configuring TUN DNS..."
    sudo "$DNS_SCRIPT" || error "DNS setup failed"
    success "DNS configured (1.1.1.1, 8.8.8.8)"
}

cmd_logs() {
    info "Following sing-box logs (Ctrl+C to exit)..."
    journalctl --user -u "$SERVICE" -f
}

cmd_ip() {
    local ip
    
    # Try primary provider (ipify) with retries
    ip=$(curl --fail --silent --connect-timeout 3 --max-time 8 --retry 2 https://api.ipify.org 2>/dev/null)
    
    # Fallback to secondary provider if primary fails
    if [[ -z "$ip" ]]; then
        ip=$(curl --fail --silent --connect-timeout 3 --max-time 8 https://ifconfig.me 2>/dev/null)
    fi
    
    # Display result
    if [[ -n "$ip" ]]; then
        # Identify if it's through a proxy based on selector default
        local current_proxy=$(jq -r '.outbounds[] | select(.type == "selector" and .tag == "proxy") | .default' "$CONFIG_FILE" 2>/dev/null)
        if [[ -n "$current_proxy" && "$current_proxy" != "direct" ]]; then
            echo -e "  ${GREEN}$ip${NC} (proxy: $current_proxy)"
        else
            echo -e "  ${YELLOW}$ip${NC} (direct)"
        fi
    else
        warn "Could not detect external IP (proxy may still be warming up)"
    fi
}

cmd_enable() {
    info "Enabling sing-box autostart..."
    systemctl --user enable "$SERVICE" || error "Failed to enable autostart"
    success "Autostart enabled"
}

cmd_disable() {
    info "Disabling sing-box autostart..."
    systemctl --user disable "$SERVICE" || error "Failed to disable autostart"
    success "Autostart disabled"
}

# network cleanup helper
net_cleanup() {
    info "Cleaning policy routing rules..."
    for p in 9010 9003 9002 9001 9000; do
        while ip rule show | awk '{print $1}' | sed 's/://' | grep -qx $p; do
            sudo ip rule del pref $p || true
        done
    done
    if ip link show tun0 &>/dev/null; then
        sudo resolvectl revert tun0 || true
        sudo ip link set tun0 down || true
        sudo ip link del tun0 || true
    fi
    resolvectl flush-caches || true
    success "Cleanup complete"
}

# mode helpers
cmd_mode() {
    case "${1:-}" in
        on)
            info "Enabling Sing-box system-wide..."
            cmd_up
            ;;
        off)
            info "Disabling Sing-box system-wide..."
            cmd_dns reset
            cmd_down
            net_cleanup
            ;;
        cleanup)
            net_cleanup
            ;;
        *)
            error "Usage: sbox mode {on|off|cleanup}"
            ;;
    esac
}

# Proxy management functions
cmd_list() {
    info "Available proxies:"
    jq -r '.outbounds[] | select(.type != "direct" and .type != "block" and .type != "selector") | "  • \(.tag) (\(.type))"' "$CONFIG_FILE"
    
    echo ""
    local current=$(jq -r '.outbounds[] | select(.type == "selector" and .tag == "proxy") | .default' "$CONFIG_FILE")
    if [[ -n "$current" ]]; then
        success "Active: $current"
    fi
}

cmd_current() {
    local current=$(jq -r '.outbounds[] | select(.type == "selector" and .tag == "proxy") | .default' "$CONFIG_FILE")
    if [[ -n "$current" ]]; then
        echo -e "  ${GREEN}$current${NC}"
    else
        error "No active proxy found"
    fi
}

cmd_use() {
    local tag="$1"
    [[ -z "$tag" ]] && error "Usage: sbox use <proxy-tag>"
    
    # Check if proxy exists
    local exists=$(jq -r --arg tag "$tag" '.outbounds[] | select(.tag == $tag and .type != "selector" and .type != "direct" and .type != "block") | .tag' "$CONFIG_FILE")
    [[ -z "$exists" ]] && error "Proxy '$tag' not found"
    
    info "Switching to proxy: $tag"
    
    # Update selector default
    jq --arg tag "$tag" '
      (.outbounds[] | select(.type == "selector" and .tag == "proxy") | .default) = $tag
    ' "$CONFIG_FILE" > /tmp/config-use.json && mv /tmp/config-use.json "$CONFIG_FILE"
    
    # Validate
    sing-box check -c "$CONFIG_FILE" >/dev/null || error "Config validation failed"
    
    # Restart service
    cmd_restart
}

cmd_add_ss() {
    local ss_url="$1"
    [[ -z "$ss_url" ]] && error "Usage: sbox add ss <ss://url>"
    
    # Parse SS URL (format: ss://method:password@host:port#name)
    if [[ "$ss_url" =~ ^ss://([^@]+)@([^:]+):([0-9]+)#?(.*)$ ]]; then
        local method_pass="${BASH_REMATCH[1]}"
        local server="${BASH_REMATCH[2]}"
        local port="${BASH_REMATCH[3]}"
        local name="${BASH_REMATCH[4]}"
        
        # Decode method:password
        local decoded=$(echo "$method_pass" | base64 -d 2>/dev/null || echo "$method_pass")
        local method="${decoded%%:*}"
        local password="${decoded#*:}"
        
        # Generate tag from name or server
        local tag="${name:-ss-${server}}"
        tag=$(echo "$tag" | tr ' ' '-' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]//g')
        
    else
        error "Invalid SS URL format. Expected: ss://method:password@host:port#name"
    fi
    
    info "Adding Shadowsocks proxy: $tag"
    info "  Server: $server:$port"
    info "  Method: $method"
    
    # Backup
    cp "$CONFIG_FILE" "$CONFIG_FILE.backup-before-add-$(date +%s)"
    
    # Add new outbound
    jq --arg tag "$tag" --arg server "$server" --arg port "$port" --arg method "$method" --arg password "$password" '
      .outbounds += [{
        "type": "shadowsocks",
        "tag": $tag,
        "server": $server,
        "server_port": ($port | tonumber),
        "method": $method,
        "password": $password
      }] |
      (.outbounds[] | select(.type == "selector" and .tag == "proxy") | .outbounds) += [$tag]
    ' "$CONFIG_FILE" > /tmp/config-add.json && mv /tmp/config-add.json "$CONFIG_FILE"
    
    # Validate
    if ! sing-box check -c "$CONFIG_FILE" >/dev/null 2>&1; then
        error "Config validation failed. Restoring backup."
    fi
    
    success "Proxy '$tag' added successfully"
    info "To use it: sbox use $tag"
}

# URL helpers for add vless/vmess
slugify() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[[:space:]]+/-/g; s/[^a-z0-9-]+/-/g; s/^-+|-+$//g; s/--+/-/g'
}

urldecode() {
    local data="${1//+/ }"
    printf '%b' "${data//%/\\x}"
}

qs_get() {
    local key="$1"; shift
    local qs="$1"
    local val
    val=$(echo -n "$qs" | tr '&' '\n' | grep -i -m1 "^${key}=" | cut -d= -f2-)
    urldecode "${val:-}"
}

cmd_add_vless() {
    local vless_url="$1"
    [[ -z "$vless_url" ]] && error "Usage: sbox add vless <vless://url>"

    [[ "$vless_url" =~ ^vless:// ]] || error "Invalid VLESS URL (must start with vless://)"

    local u="${vless_url#vless://}"
    local name=""
    if [[ "$u" == *"#"* ]]; then
        name="${u#*#}"
        u="${u%%#*}"
    fi

    [[ "$u" == *"@"* ]] || error "Invalid VLESS URL: missing '@'"
    local uuid="${u%%@*}"
    local rest="${u#*@}"

    local hostport="${rest%%\?*}"
    local query=""
    if [[ "$rest" == *\?* ]]; then
        query="${rest#*\?}"
    fi

    local server="${hostport%%:*}"
    local port="${hostport##*:}"

    local q_type=$(qs_get type "$query")
    local q_security=$(qs_get security "$query")
    local q_host=$(qs_get host "$query")
    local q_path=$(qs_get path "$query")
    local q_sni=$(qs_get sni "$query")
    local q_service=$(qs_get serviceName "$query")

    local transport_type="${q_type:-tcp}"
    local tls_enabled_json=false
    [[ "${q_security}" == "tls" ]] && tls_enabled_json=true

    local tag_base
    if [[ -n "$name" ]]; then
        tag_base="$name"
    else
        tag_base="vless-${server}"
    fi
    local tag
    tag=$(slugify "$tag_base")

    info "Adding VLESS proxy: $tag"
    info "  Server: $server:$port"
    info "  Transport: $transport_type${q_security:+, TLS=$q_security}"

    # Prevent duplicate tags
    local exists=$(jq -r --arg tag "$tag" '.outbounds[] | select(.tag == $tag) | .tag' "$CONFIG_FILE")
    if [[ -n "$exists" ]]; then
        error "Proxy tag '$tag' already exists. Use 'sbox use $tag' or choose a different #name"
    fi

    # Backup
    cp "$CONFIG_FILE" "$CONFIG_FILE.backup-before-add-$(date +%s)"

    # Build and append outbound
    local tmp="/tmp/sbox-config-add.$$"
    jq \
      --arg tag "$tag" \
      --arg server "$server" \
      --arg port "$port" \
      --arg uuid "$uuid" \
      --arg sni "${q_sni}" \
      --arg hosthdr "${q_host}" \
      --arg path "${q_path}" \
      --arg transport_type "$transport_type" \
      --arg grpc_service "${q_service}" \
      --argjson tls_enabled "$tls_enabled_json" \
      '
      .outbounds += [
        (
          {
            "type": "vless",
            "tag": $tag,
            "server": $server,
            "server_port": ($port | tonumber),
            "uuid": $uuid
          }
          + ( if $tls_enabled
              then {"tls": {"enabled": true, "server_name": ( if ($sni|length)>0 then $sni elif ($hosthdr|length)>0 then $hosthdr else $server end ) }}
              else {}
              end )
          + ( if $transport_type == "ws"
              then {"transport": {"type": "ws", "path": $path, "headers": ( if ($hosthdr|length)>0 then {"Host": $hosthdr} else {} end ) }}
              elif $transport_type == "grpc"
              then {"transport": {"type": "grpc", "service_name": $grpc_service}}
              else {}
              end )
        )
      ]
      | (.outbounds[] | select(.type == "selector" and .tag == "proxy") | .outbounds) += [$tag]
      ' "$CONFIG_FILE" > "$tmp"

    # Validate and apply
    if ! sing-box check -c "$tmp" >/dev/null 2>&1; then
        rm -f "$tmp"
        error "Config validation failed"
    fi
    mv "$tmp" "$CONFIG_FILE"

    success "Proxy '$tag' added successfully"
    info "To use it: sbox use $tag"
}

cmd_add_vmess() {
    local vmess_url="$1"
    [[ -z "$vmess_url" ]] && error "Usage: sbox add vmess <vmess://base64>"

    [[ "$vmess_url" =~ ^vmess:// ]] || error "Invalid VMess URL (must start with vmess://)"

    local rest="${vmess_url#vmess://}"
    rest="$(urldecode "$rest")"
    local frag=""
    if [[ "$rest" == *"#"* ]]; then
        frag="${rest#*#}"
        rest="${rest%%#*}"
    fi
    local b64="$rest"
    b64="${b64%%\?*}"
    b64="$(echo -n "$b64" | tr -d '\n\r ' | sed 's/_/\//g; s/-/+/g')"
    local pad=$(( (4 - ${#b64} % 4) % 4 ))
    if (( pad > 0 )); then
        b64+=$(printf '%*s' "$pad" '' | tr ' ' '=')
    fi

    local payload
    payload=$(echo -n "$b64" | base64 -d 2>/dev/null) || error "Invalid VMess base64 payload"

    # Extract fields via jq
    local server port uuid scy net vtype host path tls sni ps
    server=$(echo "$payload" | jq -r '.add // empty')
    port=$(echo   "$payload" | jq -r '.port // empty')
    uuid=$(echo   "$payload" | jq -r '.id // empty')
    scy=$(echo    "$payload" | jq -r '.scy // "auto"')
    net=$(echo    "$payload" | jq -r '.net // "tcp"')
    vtype=$(echo  "$payload" | jq -r '.type // "none"')
    host=$(echo   "$payload" | jq -r '.host // ""')
    path=$(echo   "$payload" | jq -r '.path // ""')
    tls=$(echo    "$payload" | jq -r '.tls // ""')
    sni=$(echo    "$payload" | jq -r '.sni // ""')
    ps=$(echo     "$payload" | jq -r '.ps // ""')

    [[ -n "$server" && -n "$port" && -n "$uuid" ]] || error "Missing required VMess fields (add/port/id)"

    local tls_enabled_json=false
    [[ "$tls" == "tls" ]] && tls_enabled_json=true

    local tag_base
    if [[ -n "$ps" && "$ps" != "null" ]]; then
        tag_base="$ps"
    elif [[ -n "$frag" ]]; then
        tag_base="$frag"
    else
        tag_base="vmess-${server}"
    fi
    local tag
    tag=$(slugify "$tag_base")

    info "Adding VMess proxy: $tag"
    info "  Server: $server:$port"
    info "  Network: $net${tls:+, TLS=$tls}"

    # Prevent duplicate tags
    local exists=$(jq -r --arg tag "$tag" '.outbounds[] | select(.tag == $tag) | .tag' "$CONFIG_FILE")
    if [[ -n "$exists" ]]; then
        error "Proxy tag '$tag' already exists. Use 'sbox use $tag' or choose a different #name"
    fi

    # Backup
    cp "$CONFIG_FILE" "$CONFIG_FILE.backup-before-add-$(date +%s)"

    local tmp="/tmp/sbox-config-add.$$"
    jq \
      --arg tag "$tag" \
      --arg server "$server" \
      --arg port "$port" \
      --arg uuid "$uuid" \
      --arg scy "$scy" \
      --arg net "$net" \
      --arg hosthdr "$host" \
      --arg path "$path" \
      --arg sni "$sni" \
      --argjson tls_enabled "$tls_enabled_json" \
      '
      .outbounds += [
        (
          {
            "type": "vmess",
            "tag": $tag,
            "server": $server,
            "server_port": ($port | tonumber),
            "uuid": $uuid,
            "security": $scy
          }
          + ( if $tls_enabled
              then {"tls": {"enabled": true, "server_name": ( if ($sni|length)>0 then $sni elif ($hosthdr|length)>0 then $hosthdr else $server end ) }}
              else {}
              end )
          + ( if $net == "ws"
              then {"transport": {"type": "ws", "path": $path, "headers": ( if ($hosthdr|length)>0 then {"Host": $hosthdr} else {} end ) }}
              else {}
              end )
        )
      ]
      | (.outbounds[] | select(.type == "selector" and .tag == "proxy") | .outbounds) += [$tag]
      ' "$CONFIG_FILE" > "$tmp"

    # Validate and apply
    if ! sing-box check -c "$tmp" >/dev/null 2>&1; then
        rm -f "$tmp"
        error "Config validation failed"
    fi
    mv "$tmp" "$CONFIG_FILE"

    success "Proxy '$tag' added successfully"
    info "To use it: sbox use $tag"
}

cmd_help() {
    cat <<EOF
${BLUE}sbox${NC} - sing-box TUN proxy manager

${YELLOW}Usage:${NC}
  sbox <command> [options]

${YELLOW}Service Commands:${NC}
  ${GREEN}up${NC}, ${GREEN}connect${NC}       Start sing-box + configure DNS
  ${GREEN}down${NC}, ${GREEN}disconnect${NC}   Stop sing-box
  ${GREEN}restart${NC}              Restart sing-box + configure DNS
  ${GREEN}status${NC}               Show service status and IPs
  ${GREEN}dns${NC}                  Configure TUN DNS manually
  ${GREEN}dns reset${NC}            Reset TUN DNS to system default
  ${GREEN}logs${NC}                 Follow live logs
  ${GREEN}ip${NC}                   Show external IP quickly
  ${GREEN}enable${NC}               Enable autostart on login
  ${GREEN}disable${NC}              Disable autostart

${YELLOW}Proxy Management:${NC}
  ${GREEN}list${NC}                 List all available proxies
  ${GREEN}current${NC}              Show currently active proxy
  ${GREEN}use${NC} <tag>            Switch to a different proxy
  ${GREEN}add ss${NC} <url>         Add Shadowsocks proxy from URL
  ${GREEN}add vless${NC} <url>      Add VLESS proxy from URL
  ${GREEN}add vmess${NC} <url>      Add VMess proxy from URL

${YELLOW}Examples:${NC}
  sbox up                   # Start proxy
  sbox list                 # Show all proxies
  sbox use thailand-proxy   # Switch proxy
  sbox add ss 'ss://...'    # Add new SS key
  sbox status               # Check status
  sbox ip                   # Quick IP check

${YELLOW}Adding SS Keys:${NC}
  sbox add ss 'ss://method:password@host:port#name'
  Example:
    sbox add ss 'ss://chacha20-ietf-poly1305:password@1.2.3.4:8388#MyProxy'

${YELLOW}Adding VLESS Keys:${NC}
  sbox add vless 'vless://UUID@host:port?type=ws&security=tls&host=example.com&path=%2Ffoo%2F%3Fed%3D2560&sni=example.com#MyVLESS'

${YELLOW}Adding VMess Keys:${NC}
  sbox add vmess 'vmess://BASE64_JSON#MyVMess'
  # BASE64_JSON is a base64-encoded JSON containing fields like add, port, id, net, tls, sni, host, path, ps

${YELLOW}Documentation:${NC}
  ~/.config/sing-box/SETUP-SUMMARY.md
  ~/.config/sing-box/QUICK-REFERENCE.md

EOF
}

# Main
case "${1:-help}" in
    up|connect)
        cmd_up
        ;;
    down|disconnect)
        cmd_down
        ;;
    restart)
        cmd_restart
        ;;
    status|st)
        cmd_status
        ;;
    dns)
        shift
        cmd_dns "$@"
        ;;
    logs|log)
        cmd_logs
        ;;
    ip)
        cmd_ip
        ;;
    enable)
        cmd_enable
        ;;
    disable)
        cmd_disable
        ;;
    list|ls)
        cmd_list
        ;;
    current)
        cmd_current
        ;;
    use)
        shift
        cmd_use "$@"
        ;;
    mode)
        shift
        cmd_mode "$@"
        ;;
    add)
        shift
        case "${1:-}" in
            ss)
                shift
                cmd_add_ss "$@"
                ;;
            vless)
                shift
                cmd_add_vless "$@"
                ;;
            vmess)
                shift
                cmd_add_vmess "$@"
                ;;
            *)
                error "Usage: sbox add {ss|vless|vmess} <url>"
                ;;
        esac
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        error "Unknown command: $1\nRun 'sbox help' for usage"
        ;;
esac
